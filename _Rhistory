## Iterate the dynamics 150 time steps
for(i in 3:150){
X[i] <- 3.77*X[i-1] - 3.77*X[i-1]^2 - 0.85*Y[i-1]*X[i-1] - 0.5*X[i-2]
Y[i] <- 3.78*Y[i-1] - 3.78*Y[i-1]^2
}
X
Y
predE3 <- simplex(time_series = X, E = 3, stats_only = FALSE)
library(rEDM)
predE3 <- simplex(time_series = X, E = 3, stats_only = FALSE)
## Two vectors to store data
X <- c()
Y <- c()
## Initial values
X[1] <- 0.1
Y[1] <- 0.3
X[2] <- 0.3
Y[2] <- 3.78*Y[1] - 3.78*Y[1]^2
## Iterate the dynamics 150 time steps
for(i in 3:150){
X[i] <- 3.77*X[i-1] - 3.77*X[i-1]^2 - 0.85*Y[i-1]*X[i-1] - 0.5*X[i-2]
Y[i] <- 3.78*Y[i-1] - 3.78*Y[i-1]^2
}
predE3 <- simplex(time_series = X, E = 3, stats_only = FALSE)
predE3 <- simplex(time_series = X, E = 3, stats_only = FALSE)
fits <- predE3$model_output[[1]]
plot(pred ~ time, data = fits, type = "l", col = "blue", lwd=3,
xlab="Time", ylab="X", ylim=range(fits[,2:3]))
lines(obs ~ time, data = fits, col=grey.colors(1, alpha=0.25), lwd = 6)
legend("topright", c("Observed", "Predicted"), lty=1, lwd=c(6,3),
col=c(grey.colors(1, alpha=0.25), "blue"),bty="n")
plot(pred ~ time, data = fits, type = "l", col = "blue", lwd=3,
xlab="Time", ylab="X", ylim=range(fits[,2:3]))
lines(obs ~ time, data = fits, col=grey.colors(1, alpha=0.25), lwd = 6)
legend("topright", c("Observed", "Predicted"), lty=1, lwd=c(6,3),
col=c(grey.colors(1, alpha=0.25), "blue"),bty="n")
predE2 <- simplex(time_series = X, E = c(2,3,10), stats_only = FALSE)
par(mfrow=c(1,3))
plot(pred ~ obs, data = predE2$model_output[[1]],
main = bquote("Embedding = 2, " ~ rho == .(round(predE2$rho[1],2))))
plot(pred ~ obs, data = predE2$model_output[[2]],
main = bquote("Embedding = 3, " ~ rho == .(round(predE2$rho[2],2))))
plot(pred ~ obs, data = predE2$model_output[[3]],
main = bquote("Embedding = 10, " ~ rho == .(round(predE2$rho[3],2))))
par(mfrow=c(1,1))
find.emb <- simplex(time_series = X, E = 1:10)
plot(rho ~ E, data=find.emb, type="b",
xlab = "Embedding dimensions",
ylab = expression(paste("Forecast skill (",rho,")",sep="")))
find.emb <- simplex(time_series = X, E = 1:10)
plot(rho ~ E, data=find.emb, type="b",
xlab = "Embedding dimensions",
ylab = expression(paste("Forecast skill (",rho,")",sep="")))
find.emb <- simplex(time_series = X, E = 1:10)
plot(rho ~ E, data=find.emb, type="b",
xlab = "Embedding dimensions",
ylab = expression(paste("Forecast skill (",rho,")",sep="")))
predE3tp5 <- simplex(time_series = X, E = 3, tp = 5, stats_only = FALSE)
fitstp5 <- predE3tp5$model_output[[1]]
plot(pred ~ obs, data = fitstp5)
points(pred ~ obs, data = fitstp5[nrow(fitstp5),], col = "blue", pch=19)
plot(pred ~ time, data = fitstp5, type = "l", col = "blue", lwd=3,
xlab="Time", ylab="X", ylim=range(fitstp5[,2:3]))
lines(obs ~ time, data = fitstp5, col=grey.colors(1, alpha=0.25), lwd = 6)
legend("topright", c("Observed", "Predicted"), lty=1, lwd=c(6,3),
col=c(grey.colors(1, alpha=0.25), "blue"),bty="n", cex=1.5)
dev.off()
predE3tp5 <- simplex(time_series = X, E = 3, tp = 5, stats_only = FALSE)
fitstp5 <- predE3tp5$model_output[[1]]
plot(pred ~ obs, data = fitstp5)
points(pred ~ obs, data = fitstp5[nrow(fitstp5),], col = "blue", pch=19)
plot(pred ~ time, data = fitstp5, type = "l", col = "blue", lwd=3,
xlab="Time", ylab="X", ylim=range(fitstp5[,2:3]))
lines(obs ~ time, data = fitstp5, col=grey.colors(1, alpha=0.25), lwd = 6)
legend("topright", c("Observed", "Predicted"), lty=1, lwd=c(6,3),
col=c(grey.colors(1, alpha=0.25), "blue"),bty="n", cex=1.5)
pred.decay <- simplex(time_series = X, E = 3, tp = 1:10)
plot(rho ~ tp, data=pred.decay,
type = "b",
xlab = "Time to prediction",
ylab = expression(paste("Forecast skill (",rho,")",sep="")))
X2 <- c()
X2[1] <- 0.5
for(i in 2:150)
X2[i] <- 3.569949 * X2[i-1] * ( 1- X2[i-1] )
## Plots the series
plot(X2, xlab="Time", ylab="X", type="b", lty=3)
find.emb2 <- simplex(time_series = X2, E = 1:10)
plot(rho ~ E, data=find.emb2, type="b",
ylim=c(0,1),
xlab = "Embedding dimensions",
ylab = expression(paste("Forecast skill (",rho,")",sep="")))
find.emb2 <- simplex(time_series = X2, E = 1:10)
plot(rho ~ E, data=find.emb2, type="b",
ylim=c(0,1),
xlab = "Embedding dimensions",
ylab = expression(paste("Forecast skill (",rho,")",sep="")))
pred.decay2 <- simplex(time_series = X2, E = 6, tp = 1:50)
plot(rho ~ tp, data=pred.decay2,
type = "l",
xlab = "Time to prediction",
ylab = expression(paste("Forecast skill (",rho,")",sep="")),
ylim = c(0,1))
## Adding noise
X3 <- X2 + rnorm(n = length(X2), mean = 0, sd = sd(X2))
## Plot series
plot(X3, xlab="Time", ylab="X", type="b", lty=3)
## Adding noise
X3 <- X2 + rnorm(n = length(X2), mean = 0, sd = sd(X2))
## Plot series
plot(X3, xlab="Time", ylab="X", type="b", lty=3)
pred.decay3 <- simplex(time_series = X3, E = 6, tp = 1:50)
plot(rho ~ tp, data=pred.decay3,
type = "l",
xlab = "Time to prediction",
ylab = expression(paste("Forecast skill (",rho,")",sep="")),
ylim = c(0,1))
library(knitr)#; library(zoo); library(xts)
library(plotly)
library(rEDM)
library(ggplot2)#; library(cowplot)
library(dplyr); library(tidyr)
opts_chunk$set(fig.align = 'center',
fig.show = 'hold',
fig.height = 5,
warning = FALSE, message = FALSE, error = FALSE, echo=FALSE)
options(formatR.arrow = TRUE,width = 90)###, cache=TRUE)
## Two vectors to store data
X <- c()
Y <- c()
## Initial values
X[1] <- 0.1
Y[1] <- 0.3
X[2] <- 0.3
Y[2] <- 3.78*Y[1] - 3.78*Y[1]^2
## Iterate the dynamics 150 time steps
for(i in 3:150){
X[i] <- 3.77*X[i-1] - 3.77*X[i-1]^2 - 0.85*Y[i-1]*X[i-1] - 0.5*X[i-2]
Y[i] <- 3.78*Y[i-1] - 3.78*Y[i-1]^2
}
plot(X, xlab="Time", ylab="X", type="b", lty=3)
## Data frame with X at t0, t1 and t2
df1 <- data.frame(X.t0=X[1:(length(X)-2)],X.t1=X[2:(length(X)-1)],  X.t2=X[3:(length(X))])
## point to point Euclidian distance matrix
dist.m1 <- as.matrix(dist(df1[,1:3], upper=TRUE))
## Indexes of the 4 nearest neighbors of the last point in the time series
neigb1 <- order(dist.m1[(ncol(dist.m1)-1),])[2:5]
## Plot of the manifold: add colored markers on last point and their neighbors
p3 <- plot_ly(df1, x = ~X.t0, y=~X.t1, z=~X.t2, marker=(list(color=grey)), opacity=0.25) %>%
layout(scene = list(xaxis = list(title = 'X'),
yaxis = list(title = 'X (t+1)'),
zaxis = list(title = 'X (t+2)'))) %>%
add_markers(text = paste("time =",3:length(X)), showlegend = FALSE) %>%
add_trace( x = ~X.t0, y=~X.t1, z=~X.t2, data=df1[c(length(X)-3,neigb1),],
opacity=1,
marker=list(color=c("blue","red","green","orange", "magenta")),
type="scatter3d", mode="markers",
text = paste("time =",rownames(df1[c(length(X)-3,neigb1),])), showlegend = FALSE) %>%
add_trace(data=df1[c(length(X)-3, neigb1[1]),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE) %>%
add_trace(data=df1[c(length(X)-3, neigb1[2]),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE)%>%
add_trace(data=df1[c(length(X)-3, neigb1[3]),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE) %>%
add_trace(data=df1[c(length(X)-3, neigb1[4]),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE)
p3
time1 <- min(neigb1,length(X)):length(X) # syntatic sugar
plot(time1, X[time1] , xlab="Time", ylab="X", type="b", lty=3)
cores <- c("blue", "red","green","orange", "magenta")
z <- 1
for(i in c(length(X)-3,neigb1)){
ind <- i:(i+2)
lines(ind, X[ind], type="b", col=cores[z], lwd=2, pch=19)
z <- z+1}
plot(time1, X[time1] , xlab="Time", ylab="X", type="b", lty=3)
cores <- c("blue", "red","green","orange", "magenta")
z <- 1
for(i in c(length(X)-2,neigb1+1)){
ind <- i:(i+2)
lines(ind, X[ind], type="b", col=cores[z], lwd=2, pch=19)
z <- z+1}
arrows(x0=neigb1+3, y0=X[neigb1+3], x1=length(X)*.99, y1=X[neigb1+3],
col=cores[-1])
points(length(X), X[length(X)], pch=17, cex=1.5)
s1 <- simplex(X, E=3, stats_only=FALSE)$model_output[[1]]
p1.last <- s1$pred[nrow(s1)]
pred.df <- df1[c(length(X)-2,neigb1+1),]
pred.df[1,3] <- p1.last
p4 <-
p3 %>%
add_trace( x = ~X.t0, y=~X.t1, z=~X.t2, data=pred.df,
marker=list(color=c("black","red","green","orange", "magenta")),
type="scatter3d", mode="marker",opacity=1,
text = paste("time = ",rownames(pred.df)), showlegend = FALSE) %>%
add_trace(data=pred.df[c(1,2),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE) %>%
add_trace(data=pred.df[c(1,3),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE) %>%
add_trace(data=pred.df[c(1,4),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE) %>%
add_trace(data=pred.df[c(1,5),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE) %>%
add_trace( x = ~X.t0, y=~X.t1, z=~X.t2, data=df1[nrow(df1),],
opacity=1,
marker=list(color=c("blue")),
type="scatter3d", mode="markers")
#p4
htmlwidgets::saveWidget(as_widget(p4), file = "p4.html")
include_url("p4.html", height="600px")
nich97I <- read.csv("https://www.stat.berkeley.edu/~brill/blowfly97I")
plot(nich97I$total, type="b", xlab="Time", ylab="Total number of flies")
install.packages(c("ade4", "adehabitatHR", "adehabitatLT", "adehabitatMA", "adephylo", "backports", "BoSSA", "caret", "chron", "circlize", "cowplot", "crul", "ctv", "curl", "dfoptim", "digest", "dotCall64", "DRR", "earth", "ecospat", "foreach", "fpc", "GenSA", "git2r", "haven", "hexbin", "Hmisc", "HMP", "hms", "htmlTable", "htmlwidgets", "irlba", "iterators", "KFAS", "knitr", "ks", "lava", "lme4", "MASS", "mclust", "mgcv", "msm", "pbapply", "phyclust", "phylotools", "plotrix", "pomp", "pracma", "quantmod", "rasterVis", "Rcpp", "RcppArmadillo", "RCurl", "recipes", "registry", "reshape2", "rgdal", "rgl", "rlang", "Rmpfr", "rms", "rpart", "rprojroot", "rsq", "segmented", "sf", "sp", "spam", "spatstat", "spatstat.utils", "spdep", "stargazer", "tibble", "tm", "tmap", "tmaptools", "units", "urltools", "vegan", "viridis", "webshot", "wikitaxa", "withr", "xts", "yaml", "zoo"))
install.packages(c("ade4", "adehabitatHR", "adehabitatLT", "adehabitatMA", "adephylo", "backports", "BoSSA", "caret", "chron", "circlize", "cowplot", "crul", "ctv", "curl", "dfoptim", "digest", "dotCall64", "DRR", "earth", "ecospat", "foreach", "fpc", "GenSA", "git2r", "haven", "hexbin", "Hmisc", "HMP", "hms", "htmlTable", "htmlwidgets", "irlba", "iterators", "KFAS", "knitr", "ks", "lava", "lme4", "MASS", "mclust", "mgcv", "msm", "pbapply", "phyclust", "phylotools", "plotrix", "pomp", "pracma", "quantmod", "rasterVis", "Rcpp", "RcppArmadillo", "RCurl", "recipes", "registry", "reshape2", "rgdal", "rgl", "rlang", "Rmpfr", "rms", "rpart", "rprojroot", "rsq", "segmented", "sf", "sp", "spam", "spatstat", "spatstat.utils", "spdep", "stargazer", "tibble", "tm", "tmap", "tmaptools", "units", "urltools", "vegan", "viridis", "webshot", "wikitaxa", "withr", "xts", "yaml", "zoo"))
install.packages(c("ade4", "adehabitatHR", "adehabitatLT", "adehabitatMA", "adephylo", "backports", "BoSSA", "caret", "chron", "circlize", "cowplot", "crul", "ctv", "curl", "dfoptim", "digest", "dotCall64", "DRR", "earth", "ecospat", "foreach", "fpc", "GenSA", "git2r", "haven", "hexbin", "Hmisc", "HMP", "hms", "htmlTable", "htmlwidgets", "irlba", "iterators", "KFAS", "knitr", "ks", "lava", "lme4", "MASS", "mclust", "mgcv", "msm", "pbapply", "phyclust", "phylotools", "plotrix", "pomp", "pracma", "quantmod", "rasterVis", "Rcpp", "RcppArmadillo", "RCurl", "recipes", "registry", "reshape2", "rgdal", "rgl", "rlang", "Rmpfr", "rms", "rpart", "rprojroot", "rsq", "segmented", "sf", "sp", "spam", "spatstat", "spatstat.utils", "spdep", "stargazer", "tibble", "tm", "tmap", "tmaptools", "units", "urltools", "vegan", "viridis", "webshot", "wikitaxa", "withr", "xts", "yaml", "zoo"))
install.packages(c("ade4", "adehabitatHR", "adehabitatLT", "adehabitatMA", "adephylo", "backports", "BoSSA", "caret", "chron", "circlize", "cowplot", "crul", "ctv", "curl", "dfoptim", "digest", "dotCall64", "DRR", "earth", "ecospat", "foreach", "fpc", "GenSA", "git2r", "haven", "hexbin", "Hmisc", "HMP", "hms", "htmlTable", "htmlwidgets", "irlba", "iterators", "KFAS", "knitr", "ks", "lava", "lme4", "MASS", "mclust", "mgcv", "msm", "pbapply", "phyclust", "phylotools", "plotrix", "pomp", "pracma", "quantmod", "rasterVis", "Rcpp", "RcppArmadillo", "RCurl", "recipes", "registry", "reshape2", "rgdal", "rgl", "rlang", "Rmpfr", "rms", "rpart", "rprojroot", "rsq", "segmented", "sf", "sp", "spam", "spatstat", "spatstat.utils", "spdep", "stargazer", "tibble", "tm", "tmap", "tmaptools", "units", "urltools", "vegan", "viridis", "webshot", "wikitaxa", "withr", "xts", "yaml", "zoo"))
library("rEDM")
help("make_block")
?lmerTest
help(lmerTest)
cite("lme4")
citation("lme4")
version("lme4")
packageVersion("lme4")
rm(list=ls())
setwd("/Users/marinacostarillo/Google Drive/PhD/projects")
setwd("./time-series-forams/")
# Libraries
# source("R/library.R")
library(R.utils)   # sourceDirectory function
library(lubridate) # date calculations
library(GGally)    # ggpairs function
library(tseries)   # tests series stationary
library(ggplot2)   # plots
library(reshape)   # function melt
library(corrplot)  # matrix correlation plot
library(rEDM)
library(zoo)
# Auxiliary functions
sourceDirectory("./R/aux_functions", modifiedOnly=FALSE)
# vignette("rEDM-tutorial", package="rEDM")
###### DATA ######
# GOM_NAs.csv : Gulf of Mexico sediment trap data with continuous time-steps and "NA" for intervals without data, see "README.txt" in data folder
data_na <- read.csv("data/GOM/GOM_NAs.csv", header = T, na = "NA")
# changing format to date
data_na$open <- dmy(data_na$open)
data_na$close <- dmy(data_na$close)
# transfoming columns into numeric
data_na[, c(5:ncol(data_na))] <- sapply(data_na[, c(5:ncol(data_na))], function(x) as.numeric(as.character(x)))
# warnings() OK! 'NA_resolution' and 'NA_gap' transformed into NA
# Calculating the distribution of sums and differences between consecutives samples (less than 'days_closed' apart)
distrib_list <- get_distrib_diffs(data_na, trap_name,  days_closed=7 ,overwrite = F)
# Filling in the NA_resolutions
data_use <- estimate_na_resolution(data_na, distrib_list, overwrite = F)
###### ANALYSIS ######
data_ts <- ts(data_use[,4:19])
# plot(data_ts[,c(2:11)])
# plot(data_ts[,c(12:16)])
rm(list=ls())
setwd("/Users/marinacostarillo/Google Drive/PhD/projects")
setwd("./time-series-forams/")
# Libraries
# source("R/library.R")
library(R.utils)   # sourceDirectory function
library(lubridate) # date calculations
library(GGally)    # ggpairs function
library(tseries)   # tests series stationary
library(ggplot2)   # plots
library(reshape)   # function melt
library(corrplot)  # matrix correlation plot
library(rEDM)
library(zoo)
# Auxiliary functions
sourceDirectory("./R/aux_functions", modifiedOnly=FALSE)
# vignette("rEDM-tutorial", package="rEDM")
###### DATA ######
# GOM_NAs.csv : Gulf of Mexico sediment trap data with continuous time-steps and "NA" for intervals without data, see "README.txt" in data folder
data_na <- read.csv("data/GOM/GOM_NAs.csv", header = T, na = "NA")
# changing format to date
data_na$open <- dmy(data_na$open)
data_na$close <- dmy(data_na$close)
# transfoming columns into numeric
data_na[, c(5:ncol(data_na))] <- sapply(data_na[, c(5:ncol(data_na))], function(x) as.numeric(as.character(x)))
# warnings() OK! 'NA_resolution' and 'NA_gap' transformed into NA
# Calculating the distribution of sums and differences between consecutives samples (less than 'days_closed' apart)
distrib_list <- get_distrib_diffs(data_na, trap_name,  days_closed=7 ,overwrite = F)
# Filling in the NA_resolutions
data_use <- estimate_na_resolution(data_na, distrib_list, overwrite = F)
rm(list=ls())
setwd("/Users/marinacostarillo/Google Drive/PhD/projects")
setwd("./time-series-forams/")
# Libraries
# source("R/library.R")
library(R.utils)   # sourceDirectory function
library(lubridate) # date calculations
library(GGally)    # ggpairs function
library(tseries)   # tests series stationary
library(ggplot2)   # plots
library(reshape)   # function melt
library(corrplot)  # matrix correlation plot
library(rEDM)
library(zoo)
# Auxiliary functions
sourceDirectory("./R/aux_functions", modifiedOnly=FALSE)
# vignette("rEDM-tutorial", package="rEDM")
###### DATA ######
# GOM_NAs.csv : Gulf of Mexico sediment trap data with continuous time-steps and "NA" for intervals without data, see "README.txt" in data folder
data_na <- read.csv("data/GOM/GOM_NAs.csv", header = T, na = "NA")
# changing format to date
data_na$open <- dmy(data_na$open)
data_na$close <- dmy(data_na$close)
# transfoming columns into numeric
data_na[, c(5:ncol(data_na))] <- sapply(data_na[, c(5:ncol(data_na))], function(x) as.numeric(as.character(x)))
# warnings() OK! 'NA_resolution' and 'NA_gap' transformed into NA
# Calculating the distribution of sums and differences between consecutives samples (less than 'days_closed' apart)
distrib_list <- get_distrib_diffs(data_na, days_closed=7 ,overwrite = F)
# Filling in the NA_resolutions
data_use <- estimate_na_resolution(data_na, distrib_list, overwrite = F)
data_ts <- ts(data_use[,4:19])
# plot(data_ts[,c(2:11)])
# plot(data_ts[,c(12:16)])
# Embedding dimension: output/embedding_plots
embed <- embed_dim(data_ts, emb_dim = 10, trap_name, overwrite = T) # uses simplex function rEDM, Rafa code
rm(list=ls())
setwd("/Users/marinacostarillo/Google Drive/PhD/projects")
setwd("./time-series-forams/")
# Libraries
# source("R/library.R")
library(R.utils)   # sourceDirectory function
library(lubridate) # date calculations
library(GGally)    # ggpairs function
library(tseries)   # tests series stationary
library(ggplot2)   # plots
library(reshape)   # function melt
library(corrplot)  # matrix correlation plot
library(rEDM)
library(zoo)
# Auxiliary functions
sourceDirectory("./R/aux_functions", modifiedOnly=FALSE)
# vignette("rEDM-tutorial", package="rEDM")
###### DATA ######
trap_name <- c("GOM")
# GOM_NAs.csv : Gulf of Mexico sediment trap data with continuous time-steps and "NA" for intervals without data, see "README.txt" in data folder
data_na <- read.csv("data/GOM/GOM_NAs.csv", header = T, na = "NA")
# changing format to date
data_na$open <- dmy(data_na$open)
data_na$close <- dmy(data_na$close)
# transfoming columns into numeric
data_na[, c(5:ncol(data_na))] <- sapply(data_na[, c(5:ncol(data_na))], function(x) as.numeric(as.character(x)))
# warnings() OK! 'NA_resolution' and 'NA_gap' transformed into NA
# Calculating the distribution of sums and differences between consecutives samples (less than 'days_closed' apart)
distrib_list <- get_distrib_diffs(data_na, trap_name,  days_closed=7 ,overwrite = F)
# Filling in the NA_resolutions
data_use <- estimate_na_resolution(data_na, distrib_list, overwrite = F)
data_ts <- ts(data_use[,4:19])
# plot(data_ts[,c(2:11)])
# plot(data_ts[,c(12:16)])
# Embedding dimension: output/embedding_plots
embed <- embed_dim(data_ts, emb_dim = 10, trap_name, overwrite = T) # uses simplex function rEDM, Rafa code
sourceDirectory("./R/aux_functions", modifiedOnly=FALSE)
embed <- embed_dim(data_ts, emb_dim = 10, trap_name, overwrite = T) # uses simplex function rEDM, Rafa code
sourceDirectory("./R/aux_functions", modifiedOnly=FALSE)
embed <- embed_dim(data_ts, emb_dim = 10, trap_name, overwrite = T) # uses simplex function rEDM, Rafa code
Emb1<-data.frame()
sp<-colnames(data_ts)
# Optimized embeding dimension by eye (looking at each species plots)
emax_eye = c(3,3,5,2,2,2,1,2,2,5,3,10,3,5,5)
i=2
sp
lib <- c(1, NROW(data_ts[,i]))
pred <- lib
simplex_output <- simplex(as.data.frame(data_ts)[,i], lib = lib, pred = pred, E = 1:emb_dim, silent = T)
emb_dim=10
lib <- c(1, NROW(data_ts[,i]))
pred <- lib
simplex_output <- simplex(as.data.frame(data_ts)[,i], lib = lib, pred = pred, E = 1:emb_dim, silent = T)
simplex_output
Emb1[i,"species"]<-sp[i]
Emb1[i,"emax_auto"]<-which.max(simplex_output$rho)
Emb1[i,"rho_auto"]<-simplex_output[which.max(simplex_output$rho),"rho"]
Emb1[i,"emax_eye"]<-emax_eye[i-1]
Emb1[i,"rho_eye"]<-simplex_output[emax_eye[i-1],"rho"]
Emb1
plot(x=simplex_output$E, y=simplex_output$rho, type = "b", xlab = "Embedding dimension (E)",
ylab = expression(paste("Forecast skill (",rho,")",sep = "")), cex.lab=1.5)
dev.off()
dev.off()
dev.off()
dev.off()
plot(x=simplex_output$E, y=simplex_output$rho, type = "b", xlab = "Embedding dimension (E)",
ylab = expression(paste("Forecast skill (",rho,")",sep = "")), cex.lab=1.5)
max(simplex_output$rho)
points(max(simplex_output$rho) ~ simplex_output$E[which.max(simplex_output$rho)],  type = "b", col  =  "red", lwd=2, pch=19)
sourceDirectory("./R/aux_functions", modifiedOnly=FALSE)
rm(list=ls())
setwd("/Users/marinacostarillo/Google Drive/PhD/projects")
setwd("./time-series-forams/")
# Libraries
# source("R/library.R")
library(R.utils)   # sourceDirectory function
library(lubridate) # date calculations
library(GGally)    # ggpairs function
library(tseries)   # tests series stationary
library(ggplot2)   # plots
library(reshape)   # function melt
library(corrplot)  # matrix correlation plot
library(rEDM)
library(zoo)
# Auxiliary functions
sourceDirectory("./R/aux_functions", modifiedOnly=FALSE)
# vignette("rEDM-tutorial", package="rEDM")
###### DATA ######
trap_name <- c("GOM")
# GOM_NAs.csv : Gulf of Mexico sediment trap data with continuous time-steps and "NA" for intervals without data, see "README.txt" in data folder
data_na <- read.csv("data/GOM/GOM_NAs.csv", header = T, na = "NA")
# changing format to date
data_na$open <- dmy(data_na$open)
data_na$close <- dmy(data_na$close)
# transfoming columns into numeric
data_na[, c(5:ncol(data_na))] <- sapply(data_na[, c(5:ncol(data_na))], function(x) as.numeric(as.character(x)))
# warnings() OK! 'NA_resolution' and 'NA_gap' transformed into NA
# Calculating the distribution of sums and differences between consecutives samples (less than 'days_closed' apart)
distrib_list <- get_distrib_diffs(data_na, trap_name,  days_closed=7 ,overwrite = F)
# Filling in the NA_resolutions
data_use <- estimate_na_resolution(data_na, distrib_list, overwrite = F)
###### ANALYSIS ######
data_ts <- ts(data_use[,4:19])
# plot(data_ts[,c(2:11)])
# plot(data_ts[,c(12:16)])
# Embedding dimension: output/embedding_plots
embed <- embed_dim(data_ts, emb_dim = 10, trap_name, overwrite = T) # uses simplex function rEDM, Rafa code
simplex_plot(data_ts, emax = embed$emax_eye, trap_name, overwrite = T)
smap_plots(data_ts, emax = embed$emax_eye, trap_name, overwrite = T)
embed
lib <- c(1, NROW(data_ts[,i]))
pred <- lib
simplex_output <- simplex(as.data.frame(data_ts)[,i], lib = lib, pred = pred, E = 1:emb_dim, silent = T)
i=2
lib <- c(1, NROW(data_ts[,i]))
pred <- lib
simplex_output <- simplex(as.data.frame(data_ts)[,i], lib = lib, pred = pred, E = 1:emb_dim, silent = T)
emb_dim = 10
lib <- c(1, NROW(data_ts[,i]))
pred <- lib
simplex_output <- simplex(as.data.frame(data_ts)[,i], lib = lib, pred = pred, E = 1:emb_dim, silent = T)
lib <- c(1, NROW(data_ts[,i]))
pred <- lib
simplex_output <- simplex(as.data.frame(data_ts)[,i], lib = lib, pred = pred, E = 1:emb_dim, silent = T)
Emb1[i,"species"]<-sp[i]
Emb1<-data.frame()
sp<-colnames(data_ts)
# Optimized embeding dimension by eye (looking at each species plots)
emax_eye = c(3,3,5,2,2,2,1,2,2,5,3,10,3,5,5)
lib <- c(1, NROW(data_ts[,i]))
pred <- lib
simplex_output <- simplex(as.data.frame(data_ts)[,i], lib = lib, pred = pred, E = 1:emb_dim, silent = T)
Emb1[i,"species"]<-sp[i]
sp[i]
Emb1[i,"emax_auto"]<-which.max(simplex_output$rho)
Emb1[i,"rho_auto"]<-simplex_output[which.max(simplex_output$rho),"rho"]
embed
max(simplex_output$rho)
max(simplex_output$rho) + 0.03
max(simplex_output$rho) - 0.03
f
which(simplex_output$rho > max(simplex_output$rho) - 0.02) # finding other maxima
simplex_output$rho
simplex_output[which(simplex_output$rho > max(simplex_output$rho) - 0.02),] # finding other maxima
sp[i]
plot(x=simplex_output$E, y=simplex_output$rho, type = "b", xlab = "Embedding dimension (E)",
ylab = expression(paste("Forecast skill (",rho,")",sep = "")), cex.lab=1.5)
points(max(simplex_output$rho) ~ simplex_output$E[which.max(simplex_output$rho)],  type = "b", col  =  "red", lwd=2, pch=19)
min(simplex_output[which(simplex_output$rho > max(simplex_output$rho) - 0.02),"E"] # finding other maxima
savename<-paste("output/",trap_name,"/embedding_plots/",sp[i], "_E",emb_dim,".png",sep="")
png(savename, width = 800, height = 600)
par(mfrow = c(1,1),mar = c(4, 5, 1, 1), mgp = c(2.5, 1, 0))
plot(x=simplex_output$E, y=simplex_output$rho, type = "b", xlab = "Embedding dimension (E)",
ylab = expression(paste("Forecast skill (",rho,")",sep = "")), cex.lab=1.5)
points(max(simplex_output$rho) ~ simplex_output$E[which.max(simplex_output$rho)],  type = "b", col  =  "red", lwd=2, pch=19)
dev.off()
} # for
Emb1 <- Emb1[-1,]
Emb1[,"rho_diff"] <- Emb1[,"rho_auto"] - Emb1[,"rho_eye"]
write.csv(Emb1, paste("output/",trap_name,"/embedding_plots_",trap_name,".csv",sep=""), row.names = F)
return(Emb1)
}else{
Emb1 <- read.csv(paste("output/",trap_name,"/embedding_plots_",trap_name,".csv",sep=""), header = TRUE, stringsAsFactors = FALSE)
return (Emb1)
}
} # function
min(simplex_output[which(simplex_output$rho > max(simplex_output$rho) - 0.02),"E"]) # finding other maxima
Emb1[i,"emax_opt"]<-min(simplex_output[which(simplex_output$rho > max(simplex_output$rho) - 0.02),"E"]) # finding other maxima
simplex_output[Emb1[i,"emax_opt"],"rho"]
simplex_output[Emb1[i,"emax_opt"],]
simplex_output
_
sourceDirectory("./R/aux_functions", modifiedOnly=FALSE)
embed <- embed_dim(data_ts, emb_dim = 10, trap_name, overwrite = T) # uses simplex function rEDM, Rafa code
sourceDirectory("./R/aux_functions", modifiedOnly=FALSE)
embed <- embed_dim(data_ts, emb_dim = 10, trap_name, overwrite = T) # uses simplex function rEDM, Rafa code
embed
embed <- embed_dim(data_ts, emb_dim = 10, trap_name, overwrite = T) # uses simplex function rEDM, Rafa code
embed
emax
# Embedding dimension: output/embedding_plots
embed <- embed_dim(data_ts, emb_dim = 10, trap_name, overwrite = T) # uses simplex function rEDM, Rafa code
emax <- embed$emax_auto
# Simplex prediction and prediction decay: output/simplex_plots
simplex_plot(data_ts, emax, trap_name, overwrite = T)
# S-maps (theta): output/smap_plots
# Red noise vs. nonlinear deterministic behaviour: if forecast skill increases for theta > 0, then the results are suggestive of nonlinear dynamics
smap_plots(data_ts, emax, trap_name, overwrite = T)
